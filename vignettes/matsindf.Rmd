---
title: "<tt>matsindf</tt> Vignette"
author: "Matthew Kuperus Heun"
date: "`r Sys.Date()`"
header-includes:
   - \usepackage{amsmath}
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{matsindf Vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(dplyr)
library(tidyr)
library(tibble)
library(byname)
library(matsindf)
```

<!-- Establish some helpful LaTeX shortcuts for equations -->
\newcommand{\transpose}[1]{#1^\mathrm{T}}
\newcommand{\inverse}[1]{#1^{\textnormal{-}1}}
\newcommand{\mat}[1]{\mathbf{#1}}
\newcommand{\colvec}[1]{\mathbf{#1}}
\newcommand{\rowvec}[1]{\transpose{\colvec{#1}}}
\newcommand{\inversetranspose}[1]{\transpose{\left( \inverse{\mat{#1}} \right)}}
\newcommand{\transposeinverse}[1]{\inverse{\left( \transpose{\mat{#1}} \right)}}
\newcommand{\hatinv}[1]{\inverse{\widehat{#1}}}


## Introduction

Matrices are important mathematical objects, 
and they often describe networks of flows among nodes. 
Examples of flows and nodes are

* nutrients and organisms,
* materials and industries, and
* money and economic sectors.

Matrices provide automatic organization of network-wide calculations,
thereby simplifying the work of analysts who study entire networks.

But [wouldn't it be nice](https://en.wikipedia.org/wiki/Wouldn%27t_It_Be_Nice) ...

* ... if matrix algebra functions in <tt>R</tt> and other languages
respected names 
of matrix rows and columns (<tt>dimnames</tt> in <tt>R</tt>)?
If that were possible,
analysts would be freed from the task of aligning rows and columns of 
operand matrices passed to matrix algebra functions.
* ... if there were an easy way to create data frames
whose entries are not numbers but entire matrices?
If that were possible, 
matrix algebra could be performed on columns
of similar matrices.
* ... if matrix algebra could be conducted within data frames using 
[<tt>dplyr</tt>](http://dplyr.tidyverse.org),
[<tt>tidyr</tt>](http://tidyr.tidyverse.org), 
and other
[<tt>tidyverse</tt>](http://www.tidyverse.org)
functions?
If that were possible, 
analysts could combine the powers of matrix mathematics and
<tt>tidyverse</tt> functional programming.

The first and third items are made possible by the <tt>byname</tt> package.
(See <tt>vignette("byname")</tt>.)
The middle item 
(an easy way to create data frames
whose entries are not numbers but entire matrices)
is why <tt>matsindf</tt> exists.


## <tt>matsindf</tt>

The <tt>matsindf</tt> package provides functions to convert 
a suitably-formatted 
[tidy](http://tidyr.tidyverse.org/articles/tidy-data.html) 
data frame into a data frame containing columns of matrices.
When <tt>matsindf</tt> functions are used 
in conjunction with the <tt>byname</tt> package, 
analysts can wield the power of both 
[matrix mathematics](https://en.wikipedia.org/wiki/Matrix_(mathematics)) and 
[<tt>tidyverse</tt>](http://www.tidyverse.org) 
functional programming.
This vignette demonstrates the use of these packages
and suggests a workflow to accomplish
sophisticated analyses using *matrices in data frames* (<tt>matsindf</tt>).


## Example data

To demonstrate the use of <tt>matsindf</tt> functions,
consider flows of energy from the environment,
through transformation and distribution processes, and, ultimately,
to final demand.
Such energy flow networks are called energy conversion chains (ECCs), and
this example is an approximation to a portion of the UK's ECC circa 2000.
(Note that these data are to be used for demonstration purposes only and
have been rounded to 1--2 significant digits.)
This example first appeared in Figures 3 and 4 of the paper:

> M.K. Heun, A. Owen, and P.E. Brockway.
> [A physical supply-use table framework for energy analysis 
> on the energy conversion 
> chain](http://www.see.leeds.ac.uk/fileadmin/Documents/research/sri/workingpapers/sri-wp111.pdf).
> Sustainability Research Institute Paper 111,
> University of Leeds, School of Earth and Environment,
> Sustainability Research Institute,
> Leeds, England,
> 13 November 2017.

```{r}
head(UKEnergy2000)
```

<tt>Country</tt> and <tt>Year</tt> contain single values, 
<tt>GB</tt> and <tt>2000</tt>, respectively.
Following conventions from the [International Energy Agency](http://www.iea.org)'s 
[energy balance tables](http://www.iea.org/statistics/relateddatabases/worldenergystatisticsandbalances/), 

* <tt>Ledger.side</tt> indicates <tt>Supply</tt> and <tt>Consumption</tt>;
* <tt>Flow.aggregation.point</tt> indicates how data are to be aggregated;
* <tt>Flow</tt> indicates the industry, machine, or economic sector for this flow;
* <tt>Product</tt> indicates the energy carrier in this flow; and 
* <tt>E.ktoe</tt> gives the magnitude of the flow 
in units of [kilotons of oil equivalent](https://www.iea.org/statistics/resources/unitconverter/)
(ktoe).

The remainder of this vignette demonstrates an analysis conducted with the
<tt>UKEnergy2000</tt> data frame. 
It:

* shows how to *collapse* the data into appropriate matrices stored in columns of a data frame,
* demonstrates manipulation of the matrices with <tt>byname</tt> functions,
* illustrates *expand*ing the matrices back into a tidy data frame, and
* uses [<tt>ggplot</tt>](http://ggplot2.tidyverse.org) to graph the results.


## Suggested workflow

### Prepare for *collapse*

The <tt>EnergyUK2000</tt> data frame is similar to 
"cleaned" data from an external source: 
there are no missing entries, and 
it is [tidy](http://tidyr.tidyverse.org/articles/tidy-data.html).
But the data are not organized as matrices.

The <tt>collapse_to_matrices</tt> function converts a tidy data frame into a 
<tt>matsindf</tt> data frame using using appropriate metadata columns. 
So the first task is to prepare for *collapse* by adding metadata columns.

<tt>collapse_to_matrices</tt> needs the following information:

| metadata                        | <tt>collapse_to_matrices</tt> argument
|--------------------------------:|---------------------
| Column of matrix names          | <tt>matnames</tt>
| Column of matrix row names      | <tt>rownames</tt>
| Column of matrix column name    | <tt>colnames</tt>
| Column of matrix row types      | <tt>rowtypes</tt>
| Column of matrix column types   | <tt>coltypes</tt>
| Column of matrix entries        | <tt>values</tt>

```{r}
UKEnergy2000_with_metadata <- UKEnergy2000 %>% 
  mutate(
    # Add a column that indicates the matrix in which this entry belongs.
    UVY = case_when(
      # All negative values on the Supply side of the ledger belong in the use (U) matrix.
      Ledger.side == "Supply" & E.ktoe <= 0 ~ "U",
      # All positive values on the Supply side of the ledger belong in the make (V) matrix.
      Ledger.side == "Supply" & E.ktoe > 0 ~ "V",
      # All Consumption items belong in the final demand (Y) matrix.
      Ledger.side == "Consumption" ~ "Y", 
      # Identify any places where our logic is faulty.
      TRUE ~ NA_character_
    ),
    # Columns for rownames, colnames, rowtypes, and coltypes 
    # use the matrix name column (UVY) as their key,
    # together with the knowledge that
    # U is Product by Industry, 
    # V is Industry by Product, and 
    # Y is Product by (final demand) Sector.
    rownames = case_when(
      UVY == "U" ~ Product,
      UVY == "V" ~ Flow,
      UVY == "Y" ~ Product,
      TRUE ~ NA_character_
    ), 
    colnames = case_when(
      UVY == "U" ~ Flow,
      UVY == "V" ~ Product,
      UVY == "Y" ~ Flow,
      TRUE ~ NA_character_
    ), 
    rowtypes = case_when(
      UVY == "U" ~ "Product",
      UVY == "V" ~ "Industry",
      UVY == "Y" ~ "Product",
      TRUE ~ NA_character_
    ), 
    coltypes = case_when(
      UVY == "U" ~ "Industry",
      UVY == "V" ~ "Product",
      UVY == "Y" ~ "Sector",
      TRUE ~ NA_character_
    )
  ) %>% 
  mutate(
    # Eliminate columns we no longer need
    Ledger.side = NULL,
    Flow.aggregation.point = NULL,
    Flow = NULL,
    Product = NULL, 
    # Ensure that all energy values are positive, as required for analysis.
    E.ktoe = abs(E.ktoe)
  )
```

With the metadata now in place, 
<tt>UKEnergy2000_with_metadata</tt> can be collapsed to a matsindf data frame
with the <tt>collapse_to_matrices</tt> of <tt>matsindf</tt>.
Much like the <tt>summarise</tt> function in the <tt>dplyr</tt> package,
<tt>collapse_to_matrices</tt> relies on grouping to indicate which 
rows of the tidy data frame belong in which matrices.
The usual approach is to <tt>group_by</tt> 
the <tt>matnames</tt> column and any other columns to be preserved in the output,
in this case, <tt>Country</tt> and <tt>Year</tt>.

```{r}
EnergyMats_2000 <- UKEnergy2000_with_metadata %>% 
  group_by(Country, Year, UVY) %>% 
  collapse_to_matrices(matnames = "UVY", 
                       rownames = "rownames", colnames = "colnames", 
                       rowtypes = "rowtypes", coltypes = "coltypes", 
                       values = "E.ktoe") %>% 
  rename(matrix.name = UVY, matrix = E.ktoe)

# The remaining columns are Country, Year, matrix.name, and matrix
glimpse(EnergyMats_2000)

# To access one of the matrices, try one of these approaches:
(EnergyMats_2000 %>% filter(matrix.name == "U"))[["matrix"]] # The U matrix

EnergyMats_2000$matrix[[2]] # The V matrix

EnergyMats_2000$matrix[[3]] # The Y matrix
```

To show the power of <tt>matsindf</tt> with <tt>tidyverse</tt> functional programming,
we add some noise to the data to create a second <tt>Year</tt> and another <tt>Country</tt>.
Energy balance is verified by 

$$\mat{W} = \transpose{\mat{V}} - \mat{U},$$
and

$$\mat{W}\colvec{i} - \mat{Y}\colvec{i} = \colvec{0}.$$
But energy balance fails for matrices where noise was added

```{r}
# Create rows for a fictitious country "AB"
Energy <- EnergyMats_2000 %>% 
  rbind(EnergyMats_2000 %>% mutate(Country = "AB")) %>% 
  spread(key = Year, value = matrix) %>% 
  # Add a column of multipliers to add noise.
  mutate(
    mult = runif(nrow(.), min = 0.9, max = 1.1),
    `2001` = elementproduct_byname(mult, `2000`),
    mult = NULL
  ) %>% 
  gather(key = Year, value = matrix, `2000`, `2001`) %>% 
  spread(key = matrix.name, value = matrix) %>% 
  # Check energy balance
  mutate(
    W = difference_byname(transpose_byname(V), U),
    y = rowsums_byname(Y),
    # Need to set column name and type on y so it can be subtracted from row sums of W
    err = difference_byname(rowsums_byname(W), 
                            y %>% setcolnames_byname("Industry") %>% setcoltype("Industry"))
  )
Energy %>% select(Year, Country, err) %>% arrange(Year)
```









Data frames of matrices, 
such as those created by <tt>matsindf</tt>,
are like magic spreadsheets 
in which single cells contain entire matrices.



A suggested analysis workflow is as follows:

* Munge data into tidy data frame with columns for matrix name, 
row name, column name, row type, column type, and element value,
similar to <tt>tidy</tt> above.
* Use <tt>matsindf::collapse_to_matrices</tt>
to create a data frame of matrices with columns for matrix names and 
matrices themselves,
similar to <tt>mats</tt> above.
* <tt>tidyr::spread</tt> the matrices to obtain a data frame with columns for each matrix,
similar to <tt>results</tt> above.
* Perform matrix algebra operations on the columns of matrices
using <tt>byname</tt> functions.
* <tt>tidyr::gather</tt> the columns to obtain a tidy data frame of matrices.
* Use <tt>matsindf::expand_to_tidy</tt> to create a tidy data frame of matrix elements.
* <tt>tidyr::spread</tt> the data as necessary.
* Graph or perform other manipulations of the data.





... if cells of a magic spreadsheet could contain entire matrices?
If that were possible, 
matrix algebra operations could be performed with simple formulas
such as <tt>=A3 + A4</tt>,
where <tt>A3</tt> and <tt>A4</tt> are cells that contain matrices.

