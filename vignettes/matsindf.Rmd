---
title: "<tt>matsindf</tt> Vignette"
author: "Matthew Kuperus Heun"
date: "`r Sys.Date()`"
header-includes:
   - \usepackage{amsmath}
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{matsindf Vignette}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
references:
- id: heun2017
  title: A physical supply-use table framework for energy analysis on the energy conversion chain
  author:
  - family: Heun
    given: Matthew
  - family: Owen
    given: Anne
  - family: Brockway
    given: Paul
  container-title: Sustainability Research Institute Papers
  volume: 111
  URL: 'http://www.see.leeds.ac.uk/fileadmin/Documents/research/sri/workingpapers/sri-wp111.pdf'
  publisher: University of Leeds, School of Earth and Environment, Sustainability Research Institute
  page: 
  type: article-journal
  issued:
    year: 2017
    month: 13 November
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(dplyr)
library(tidyr)
library(tibble)
library(ggplot2)
library(byname)
library(matsindf)
```

<!-- Establish some helpful LaTeX shortcuts for equations -->
\newcommand{\transpose}[1]{#1^\mathrm{T}}
\newcommand{\inverse}[1]{#1^{\mathrm{-}1}}
\newcommand{\mat}[1]{\mathbf{#1}}
\newcommand{\colvec}[1]{\mathbf{#1}}
\newcommand{\rowvec}[1]{\transpose{\colvec{#1}}}
\newcommand{\inversetranspose}[1]{\transpose{\left( \inverse{\mat{#1}} \right)}}
\newcommand{\transposeinverse}[1]{\inverse{\left( \transpose{\mat{#1}} \right)}}
\newcommand{\hatinv}[1]{\inverse{\widehat{#1}}}


## Introduction

Matrices are important mathematical objects, 
and they often describe networks of flows among nodes. 
Example networks are given in the following table.

| System type   | Flows      | Nodes
|:--------------|:-----------|:---------
| Ecological    | nutrients  | organisms
| Manufacturing | materials  | factories
| Economic      | money      | economic sectors

The power of matrices lies in their ability 
to organize network-wide calculations,
thereby simplifying the work of analysts who study entire systems.

But [wouldn't it be nice](https://en.wikipedia.org/wiki/Wouldn%27t_It_Be_Nice) 
if there were an easy way to create data frames
whose entries were not numbers but entire matrices?
If that were possible, 
matrix algebra could be performed on columns
of similar matrices.

That's the reason for <tt>matsindf</tt>.
It provides functions to convert 
a suitably-formatted 
[tidy](http://tidyr.tidyverse.org/articles/tidy-data.html) 
data frame into a data frame containing a column of matrices.

Furthermore, <tt>byname</tt> is a sister package that ...

* ... provides matrix algebra functions that respect names of matrix rows and columns
(<tt>dimnames</tt> in <tt>R</tt>)
to free the analyst from the task of aligning rows and columns of 
operands (matrices) passed to matrix algebra functions and
* ... allows matrix algebra to be conducted within data frames using 
[<tt>dplyr</tt>](http://dplyr.tidyverse.org),
[<tt>tidyr</tt>](http://tidyr.tidyverse.org), 
and other
[<tt>tidyverse</tt>](http://www.tidyverse.org)
functions.

When used together, <tt>matsindf</tt> and <tt>byname</tt>
allow analysts to wield the power of both 
[matrix mathematics](https://en.wikipedia.org/wiki/Matrix_(mathematics))
and 
[<tt>tidyverse</tt>](http://www.tidyverse.org) 
functional programming simultaneously.

This vignette demonstrates the use of these packages
and suggests a workflow to accomplish
sophisticated analyses using *matrices in data frames* (<tt>matsindf</tt>).


## Data: <tt>UKEnergy2000</tt>

To demonstrate the use of <tt>matsindf</tt> functions,
consider a network of energy flows from the environment,
through transformation and distribution processes, and, ultimately,
to final demand.
Such energy flow networks are called energy conversion chains (ECCs), and
this example is based on an approximation to a portion of the UK's ECC circa 2000.
(Note that these data are to be used for demonstration purposes only and
have been rounded to 1--2 significant digits.)
These example data first appeared in Figures 3 and 4 
of Heun, Owen, and Brockway [-@heun2017].

```{r}
head(UKEnergy2000)
```

<tt>Country</tt> and <tt>Year</tt> contain only one value each, 
<tt>GB</tt> and <tt>2000</tt> respectively.
Following conventions of the [International Energy Agency](http://www.iea.org)'s 
[energy balance tables](http://www.iea.org/statistics/relateddatabases/worldenergystatisticsandbalances/), 

* <tt>Ledger.side</tt> indicates <tt>Supply</tt> or <tt>Consumption</tt>;
* <tt>Flow.aggregation.point</tt> indicates how data are to be aggregated;
* <tt>Flow</tt> indicates the industry, machine, or final demand sector for this flow;
* <tt>Product</tt> indicates the energy carrier for this flow; and 
* <tt>E.ktoe</tt> gives the magnitude of this flow 
in [units](https://www.iea.org/statistics/resources/unitconverter/) of kilotons of oil equivalent
(ktoe).

Each flow is its own observation 
(its own row)
in the <tt>UKEnergy2000</tt> data frame,
making it [tidy](http://tidyr.tidyverse.org/articles/tidy-data.html).

The remainder of this vignette demonstrates an analysis conducted using the
<tt>UKEnergy2000</tt> data frame as a basis. 
It:

* shows how to *collapse* and spread 
the data into appropriate matrices stored in columns of a data frame,
* demonstrates analyzing the matrices with <tt>byname</tt> functions,
* illustrates *expand*ing the matrices back into a tidy data frame, and
* uses [<tt>ggplot</tt>](http://ggplot2.tidyverse.org) to graph the results.


## Suggested workflow

### Prepare for *collapse*

The <tt>EnergyUK2000</tt> data frame is similar to 
"cleaned" data from an external source: 
there are no missing entries, and 
it is [tidy](http://tidyr.tidyverse.org/articles/tidy-data.html).
But the data are not organized as matrices,
and additional metadata is needed.

The <tt>collapse_to_matrices</tt> function converts a tidy data frame into a 
<tt>matsindf</tt> data frame using using information within the tidy data frame.
So the first task is to prepare for *collapse* by adding metadata columns.

<tt>collapse_to_matrices</tt> needs the following information:

| argument to <tt>collapse_to_matrices</tt>   | identifies
|--------------------------------------------:|:--------------------------------
| <tt>matnames</tt>                           | Name of the input column of matrix names          
| <tt>values</tt>                             | Name of the input column of matrix entries        
| <tt>rownames</tt>                           | Name of the input column of matrix row names      
| <tt>colnames</tt>                           | Name of the input column of matrix column name    
| <tt>rowtypes</tt>                           | Name of the input column of matrix row types      
| <tt>coltypes</tt>                           | Name of the input column of matrix column types   

The following code gives the approach to adding metadata,
appropriate for this application, 
relying on <tt>Ledger.side</tt>, the sign of <tt>E.ktoe</tt>,
and knowledge about the rows and columns for each matrix.
Each type of network will have its own algorithm for identifying 
row names, column names, row types, and column types
in a tidy data frame.

```{r}
UKEnergy2000_with_metadata <- UKEnergy2000 %>% 
  mutate(
    # Add a column that indicates the matrix in which this entry belongs.
    UVY = case_when(
      # All negative values on the Supply side of the ledger belong in the use (U) matrix.
      Ledger.side == "Supply" & E.ktoe <= 0 ~ "U",
      # All positive values on the Supply side of the ledger belong in the make (V) matrix.
      Ledger.side == "Supply" & E.ktoe > 0 ~ "V",
      # All Consumption items belong in the final demand (Y) matrix.
      Ledger.side == "Consumption" ~ "Y", 
      # Identify any places where our logic is faulty.
      TRUE ~ NA_character_
    ),
    # The rownames, colnames, rowtypes, and coltypes columns
    # are constructed using 
    # the matrix name column (in this case, UVY) as a key,
    # together with the knowledge that
    # U is a Product-by-Industry matrix, 
    # V is a Industry-by-Product matrix, and 
    # Y is a Product-by-Final-Demand-Sector matrix.
    rownames = case_when(
      UVY == "U" ~ Product,
      UVY == "V" ~ Flow,
      UVY == "Y" ~ Product,
      TRUE ~ NA_character_
    ), 
    colnames = case_when(
      UVY == "U" ~ Flow,
      UVY == "V" ~ Product,
      UVY == "Y" ~ Flow,
      TRUE ~ NA_character_
    ), 
    rowtypes = case_when(
      UVY == "U" ~ "Product",
      UVY == "V" ~ "Industry",
      UVY == "Y" ~ "Product",
      TRUE ~ NA_character_
    ), 
    coltypes = case_when(
      UVY == "U" ~ "Industry",
      UVY == "V" ~ "Product",
      UVY == "Y" ~ "Sector",
      TRUE ~ NA_character_
    )
  ) %>% 
  mutate(
    # Eliminate columns we no longer need
    Ledger.side = NULL,
    Flow.aggregation.point = NULL,
    Flow = NULL,
    Product = NULL, 
    # Ensure that all energy values are positive, as required for analysis.
    E.ktoe = abs(E.ktoe)
  )
```


### Collapse

With the metadata now in place, 
<tt>UKEnergy2000_with_metadata</tt> can be collapsed to a <tt>matsindf</tt> data frame
by the <tt>collapse_to_matrices</tt> function.
Much like <tt>dplyr::summarise</tt>,
<tt>collapse_to_matrices</tt> relies on grouping to indicate which 
rows of the tidy data frame belong to which matrices.
The usual approach is to <tt>tidyr::group_by</tt> 
the <tt>matnames</tt> column and any other columns to be preserved in the output,
in this case <tt>Country</tt> and <tt>Year</tt>.

```{r}
EnergyMats_2000 <- UKEnergy2000_with_metadata %>% 
  group_by(Country, Year, UVY) %>% 
  collapse_to_matrices(matnames = "UVY", values = "E.ktoe",
                       rownames = "rownames", colnames = "colnames", 
                       rowtypes = "rowtypes", coltypes = "coltypes") %>% 
  rename(matrix.name = UVY, matrix = E.ktoe)

# The remaining columns are Country, Year, matrix.name, and matrix
glimpse(EnergyMats_2000)

# To access one of the matrices, try one of these approaches:
(EnergyMats_2000 %>% filter(matrix.name == "U"))[["matrix"]] # The U matrix

EnergyMats_2000$matrix[[2]] # The V matrix

EnergyMats_2000$matrix[[3]] # The Y matrix
```


### Duplicate (for purposes of illustration)

Larger studies will include data for multiple countries and years. 
The ECC data from UK in year <tt>2000</tt> can be duplicated 
for <tt>2001</tt> and 
for a fictitious country <tt>AB</tt>.
Although the data are unchanged, 
the additional rows serve to illustrate the
functional programming aspects 
of the <tt>matsindf</tt> and <tt>byname</tt> packages.

```{r}
Energy <- EnergyMats_2000 %>% 
  # Create rows for a fictitious country "AB".
  # Although these rows are same as the "GB" rows,
  # they serve to illustrate functional programming with matsindf.
  rbind(EnergyMats_2000 %>% mutate(Country = "AB")) %>% 
  spread(key = Year, value = matrix) %>% 
  mutate(
    `2001` = `2000`
  ) %>% 
  gather(key = Year, value = matrix, `2000`, `2001`) %>% 
  # Now spread to put each matrix in a column.
  spread(key = matrix.name, value = matrix)

glimpse(Energy)
```


### Verify data

An important step in any analysis is data verfication.
For an ECC analysis, it is important to verify that energy is conserved
(i.e., energy is in balance) 
across all industries.
Equations 1 and 2 in Heun, Owen, and Brockway [-@heun2017]
show that energy balance is verified by 

$$\mat{W} = \transpose{\mat{V}} - \mat{U},$$

and

$$\mat{W}\colvec{i} - \mat{Y}\colvec{i} = \colvec{0}.$$

Energy balance verification can be implemented with <tt>byname</tt> functions
and <tt>tidyverse</tt> functional programming:

```{r}
Check <- Energy %>% 
  mutate(
    W = difference_byname(transpose_byname(V), U),
    # Need to change column name and type on y so it can be subtracted from row sums of W
    err = difference_byname(rowsums_byname(W), 
                            rowsums_byname(Y) %>% 
                              setcolnames_byname("Industry") %>% setcoltype("Industry")),
    EBalOK = iszero_byname(err)
  )
Check %>% select(Country, Year, EBalOK)
all(Check$EBalOK %>% as.logical())
```

This example demonstrates that energy balance can be verified for *all* combinations
of Country and Year with a few lines of code.
In fact, the exact same code can be applied to the <tt>Energy</tt> data frame, 
regardless of the number of rows in it.

Secure in the knowledge that energy is conserved across all ECCs
in the <tt>Energy</tt> data frame, 
other analyses can proceed.


### Efficiencies

To further illustrate the power of <tt>byname</tt> functions 
in the context of <tt>matsindf</tt>,
consider the calulation of the efficiency of every industry in the ECC as column vector $\eta$ 
as shown by Equation 11 of Heun, Owen, and Brockway [-@heun2017].

$$\colvec{g} = \mat{V}\colvec{i}$$

$$\colvec{\eta} = \hatinv{\transpose{\mat{U}} \colvec{i}} \colvec{g}$$


```{r}
Etas <- Energy %>% 
  mutate(
    g = rowsums_byname(V),
    eta = transpose_byname(U) %>% rowsums_byname() %>% 
      hatize_byname() %>% invert_byname() %>% 
      matrixproduct_byname(g) %>% 
      setcolnames_byname("eta") %>% setcoltype("Efficiency")
  ) %>% 
  select(Country, Year, eta)

Etas$eta[[1]]
```

Note that only a few lines of code are required to perform the same series of 
matrix operations on every combintaion of <tt>Country</tt> and <tt>Year</tt>.
In fact, the same code will to calculate the efficiency of 
any number of industries in any number of countries and years!


### Expand

Plotting values from a <tt>matsindf</tt> data frame
can be accomplished by *expand*ing the matrices 
of the <tt>matsindf</tt> data frame (in this example, <tt>Etas</tt>)
back out to a tidy data frame.
*Expand*ing is the reverse of *collapse*-ing, and 
the following information must be supplied to the 
<tt>expand_to_tidy</tt> function:

| argument to <tt>expand_to_tidy</tt>         | identifies
|--------------------------------------------:|:--------------------------------
| <tt>matnames</tt>                           | Name of the input column of matrix names          
| <tt>matvals</tt>                            | Name of the input column of matrices to be expanded
| <tt>rownames</tt>                           | Name of the output column of matrix row names      
| <tt>colnames</tt>                           | Name of the output column of matrix column name    
| <tt>rowtypes</tt>                           | Name of the output column of matrix row types      
| <tt>coltypes</tt>                           | Name of the output column of matrix column types   
| <tt>drop</tt>                               | An optional value to be dropped from output (often 0)

Prior to <tt>expand</tt>ing, it is usually 
necessary to <tt>gather</tt> columns of matrices.

```{r}
etas_forgraphing <- Etas %>% 
  gather(key = matrix.names, value = matrix, eta) %>% 
  expand_to_tidy(matnames = "matrix.names", matvals = "matrix", 
                 rownames = "Industry", colnames = "etas", 
                 rowtypes = "rowtype", coltypes = "Efficiencies") %>% 
  mutate(
    # Eliminate columns we no longer need.
    matrix.names = NULL,
    etas = NULL, 
    rowtype = NULL, 
    Efficiencies = NULL
  ) %>% 
  rename(
    eta = matrix
  )

# Compare to Figure 8 of Heun, Owen, and Brockway (2017)
etas_forgraphing %>% filter(Country == "GB", Year == 2000)
```

<tt>etas_forgraphing</tt> is a data frame of efficiencies, 
one for each Country, Year, and Industry, 
in a format that is amenable to plotting
with packages such as [ggplot](http://ggplot2.tidyverse.org).


### Report

The following code creates a bar graph of efficiency results for the UK in 2000:

```{r}
etas_UK_2000 <- etas_forgraphing %>% filter(Country == "GB", Year == 2000) 

etas_UK_2000 %>% 
  ggplot(mapping = aes_string(x = "Industry", y = "eta", 
                              fill = "Industry", colour = "Industry")) + 
  geom_bar(stat = "identity") +
  labs(x = NULL, y = expression(eta[UK*","*2000]), fill = NULL) + 
  scale_y_continuous(breaks = seq(0, 1, by = 0.2)) +
  scale_fill_manual(values = rep("white", nrow(etas_UK_2000))) +
  scale_colour_manual(values = rep("gray20", nrow(etas_UK_2000))) + 
  guides(fill = FALSE, colour = FALSE) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.4, hjust = 1))
```


## Conclusion

This vignette demonstrated the use of the <tt>matsindf</tt> and <tt>byname</tt> packages
and suggested a workflow to accomplish
sophisticated analyses using *matrices in data frames* (<tt>matsindf</tt>).

The workflow is as follows:

* Clean data into a tidy data frame with columns for
matrix name, element value,
row name, column name, 
row type, and column type,
similar to <tt>UKEnergy2000</tt> above.
* Use <tt>collapse_to_matrices</tt>
to create a data frame of matrices with columns for matrix names and 
matrices themselves,
similar to <tt>EnergyMats_2000</tt> above.
* <tt>tidyr::spread</tt> the matrices to obtain a data frame with columns for each matrix,
similar to <tt>Energy</tt> above.
* Validate the data, similar to <tt>Check</tt> above.
* Perform matrix algebra operations on the columns of matrices
using <tt>byname</tt> functions in a manner similar to the process of generating
the <tt>Etas</tt> data frame above.
* <tt>tidyr::gather</tt> the columns to obtain a tidy data frame of matrices.
* Use <tt>expand_to_tidy</tt> to create a tidy data frame of matrix elements,
similar to <tt>etas_forgraphing</tt> above.
* Plot and report results as demonstrated by the graph above.

Data frames of matrices, 
such as those created by <tt>matsindf</tt>,
are like magic spreadsheets 
in which single cells contain entire matrices.
With this data structure, 
analysts can wield the power of both 
[matrix mathematics](https://en.wikipedia.org/wiki/Matrix_(mathematics)) and 
[<tt>tidyverse</tt>](http://www.tidyverse.org) 
functional programming simultaneously.


## References
